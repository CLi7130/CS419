#!/usr/bin/python3

import hashlib
import os
from os.path import exists
import sys
import string


# Program Syntax: python3 pow-check.py powheader file
# powheader - header output of pow-create.py
# file - original file 

# we know that headers are single lines for each data point - IE Hash: [value]
# can use readline? separate string by : character and trim whitespace?

# What needs to get done:
#   - verify the value of Initial-hash from the header (SHA-256 hash)
#   - computes hash of the intiail hash string concatenated with the Proof-of-work string in header file
#       - resulting value should match Hash header
#   - result of pow-check should be a single line with message of either 'pass' or 'fail'
#       - if any tests have failed, specify which tests have failed before printing a 'fail' message
#   - final line of program should have single 'pass' or 'fail' result.
#   - previous lines may identify checks that have passed and should identify checks that failed.
#       - use global for prev_result? keep updating with pass/fail of each test

# values read in from file
GIVEN_FILE_HASH_VAL = None
GIVEN_PROOF_OF_WORK = None
GIVEN_FINAL_HASH = None
GIVEN_LEADING_ZEROS = None

#duplicate flags
DUPLICATE_FILE_HASH_VAL = 0
DUPLICATE_PROOF_OF_WORK = 0
DUPLICATE_FINAL_HASH = 0
DUPLICATE_LEADING_ZEROS = 0

# values generated by verification
ACTUAL_FILE_HASH_VAL = None
ACTUAL_FINAL_HASH = None
ACTUAL_LEADING_ZEROS = None

# flag for failure of any test
# 0 for fail, 1 for pass
VERIFICATION_RESULT = 1

# turns on/off debugging print statements
# 0 - off, 1 - on
DEBUG = 0

# encodes a given byte array from a file with SHA-256, and returns a hash object of the byte array
def getHashValHexDigest(input):

    # SHA-256 Hash Value
    hashVal = hashlib.sha256(input)
    # String representation of hash value in hex
    hashValHexDigest = hashVal.hexdigest()
    # hashValDigest = hashVal.digest()
    if DEBUG:
        print()
        #print("hashValDigest:", hashValDigest)
        print("hashValHexDigest:", hashValHexDigest)
        print()
    
    return hashValHexDigest

# all of the error checking
#   - invalid file format
#   - see examples in part 2

# takes split of input file based on newlines (headers should only be contained to one line)
# and parses input to check for correct formatting, lack of duplicate entries, and gets values
# 
def verify_pow_file_format(input):
    # need to check for:

    # Initial-hash:
    # Proof-of-work:
    # Leading-zero-bits:
    # Hash:
    #other headers can be ignored

    input = input.split('\n')

    if DEBUG:
        print(input)
        print()

    global VERIFICATION_RESULT, GIVEN_FILE_HASH_VAL, GIVEN_PROOF_OF_WORK, GIVEN_FINAL_HASH, GIVEN_LEADING_ZEROS
    global DUPLICATE_FILE_HASH_VAL, DUPLICATE_FINAL_HASH, DUPLICATE_LEADING_ZEROS, DUPLICATE_PROOF_OF_WORK
    initialHash = None
    proofOfWork = None
    leadingZeros = None
    finalHash = None

    initialHashStart = "Initial-hash:"
    powStart = "Proof-of-work:"
    finalHashStart = "Hash:"
    leadingZerosStart = "Leading-zero-bits:"

    # assign values from split into respective vars
    for split in input:
        if DEBUG:
            print("SplitVal:", split)
        if split.startswith(initialHashStart):
            # check for duplicate values, IE initial hash is printed twice
            # should we immediately exit if format doesn't match, but values do? 
            if initialHash is not None:
                DUPLICATE_FILE_HASH_VAL = 1
            else:
                initialHash = split
        elif split.startswith(powStart):
            if proofOfWork is not None:
                DUPLICATE_PROOF_OF_WORK = 1
            else:
                proofOfWork = split
        elif split.startswith(leadingZerosStart):
            if leadingZeros is not None:
                DUPLICATE_LEADING_ZEROS = 1
            else:
                leadingZeros = split
        elif split.startswith(finalHashStart):
            if finalHash is not None:
                DUPLICATE_FINAL_HASH = 1
            else:
                finalHash = split

    
    # set verification to fail if anything is missing or has a duplicate in file
    if initialHash is None or initialHash[len(initialHashStart):].lstrip() == "":
        # missing value
        print("ERROR: missing Initial-hash in header")
        VERIFICATION_RESULT = 0
    elif DUPLICATE_FILE_HASH_VAL:
        # duplicate value found in header file
        print("ERROR: Multiple instances of Initial-hash in header")
        VERIFICATION_RESULT = 0
    else:
        # set global after trimming off header name and leading whitespace
        # this gets the actual value of the header field
        GIVEN_FILE_HASH_VAL = initialHash[len(initialHashStart):].lstrip()

    if proofOfWork is None or proofOfWork[len(powStart):].lstrip() == "":
        print("ERROR: missing Proof-of-work in header")
        VERIFICATION_RESULT = 0
    elif DUPLICATE_PROOF_OF_WORK:
        print("ERROR: Multiple instances of Proof-of-work in header")
        VERIFICATION_RESULT = 0
    else:
        GIVEN_PROOF_OF_WORK = proofOfWork[len(powStart):].lstrip()

    if leadingZeros is None or leadingZeros[len(leadingZerosStart):].lstrip() == "":
        print("ERROR: missing Leading-zero-bits in header") 
        VERIFICATION_RESULT = 0
    elif DUPLICATE_LEADING_ZEROS:
        print("ERROR: Multiple instances of Leading-zero-bits in header")
        VERIFICATION_RESULT = 0
    else:
        GIVEN_LEADING_ZEROS = leadingZeros[len(leadingZerosStart):].lstrip()

    if finalHash is None or finalHash[len(finalHashStart):].lstrip() == "":
        print("ERROR: missing Hash in header")
        VERIFICATION_RESULT = 0
    elif DUPLICATE_FINAL_HASH:
        print("ERROR: Multiple instances of Hash in header")
        VERIFICATION_RESULT = 0
    else:
        GIVEN_FINAL_HASH = finalHash[len(finalHashStart):].lstrip()
    
    if DEBUG:
        print()
        print("read values from file:")
        print(GIVEN_FILE_HASH_VAL)
        print(GIVEN_PROOF_OF_WORK)
        print(GIVEN_LEADING_ZEROS)
        print(GIVEN_FINAL_HASH)

# checks hash value given in file against the generated hash from the file given as input
# if initial hash does not match, print an error and the two initial hash values
def verify_initial_hash_values():

    global VERIFICATION_RESULT

    if DEBUG:
        print()
        print("verifying initial hashes...")
        print("given:", GIVEN_FILE_HASH_VAL)
        print("expected:", ACTUAL_FILE_HASH_VAL)
    
    # if we already have an invalid verification result, that means there wasn't an initial hash
    # included in the pow header file.
    if GIVEN_FILE_HASH_VAL is None and not DUPLICATE_FILE_HASH_VAL:
        print("ERROR: initial hashes don't match")
        print('\t' + "Initial-hash in header missing")
        print('\t' + "file hash:", ACTUAL_FILE_HASH_VAL)
        return
    elif DUPLICATE_FILE_HASH_VAL:
        print("ERROR: initial hashes don't match")
        print('\t' + "multiple Initial-hash values in header file")
        print('\t' + "file hash:", ACTUAL_FILE_HASH_VAL)
        return

    # check initial hash in pow header file against generated initial hash of file argument
    if GIVEN_FILE_HASH_VAL == ACTUAL_FILE_HASH_VAL:
        print("PASSED: initial file hashes match")
    else:
        print("ERROR: intial hashes don't match")
        print('\t' + "hash in header:", GIVEN_FILE_HASH_VAL)
        print('\t' + "file hash:", ACTUAL_FILE_HASH_VAL)
        VERIFICATION_RESULT = 0

# creates hash of given initial hash and proof of work, then counts number of leading zeros.
# compares that result against the Leading-zero-bits value we were given in the pow header file.
def verify_leading_zeros():

    global ACTUAL_LEADING_ZERO_BITS, VERIFICATION_RESULT, ACTUAL_FINAL_HASH

    if (GIVEN_PROOF_OF_WORK is None or GIVEN_PROOF_OF_WORK == "") and not DUPLICATE_PROOF_OF_WORK :
        print("ERROR: Missing Proof-of-work, cannot calculate leading zero bits")
        return
    elif DUPLICATE_PROOF_OF_WORK:
        print("ERROR: Multiple instances of Proof-of-work in header, cannot calculate leading zero bits")
        return

    if (GIVEN_FILE_HASH_VAL is None or GIVEN_FILE_HASH_VAL == "") and not DUPLICATE_FILE_HASH_VAL:
        print("ERROR: Missing Initial-hash, cannot calculate leading zero bits")
        return
    elif DUPLICATE_FILE_HASH_VAL:
        print("ERROR: Multiple instances of Initial-hash in header, cannot calculate leading zero bits")
        return

    if (GIVEN_LEADING_ZEROS is None or GIVEN_LEADING_ZEROS == "") and not DUPLICATE_LEADING_ZEROS:
        print("ERROR: Missing Leading-zero-bits")
        return
    elif DUPLICATE_LEADING_ZEROS:
        print("ERROR: Multiple instances of Leading-zero-bits in header, cannot verify")
        return
    

    leadingZeros = 0
    nonZeroVal = 0
    combinedHash = getHashValHexDigest( (GIVEN_FILE_HASH_VAL + GIVEN_PROOF_OF_WORK).encode('utf-8') )
    ACTUAL_FINAL_HASH = combinedHash
    if DEBUG:
        print()
        print("Initial Hash:", GIVEN_FILE_HASH_VAL)
        print("Proof of Work:", GIVEN_PROOF_OF_WORK)
        print("Combined Hash:", combinedHash)

    # iterate over every hex value in hash
    for hexChar in combinedHash:
        #convert to byte value - base 16, truncate first 2 chars of hex byte value
        binValue = bin(int(hexChar, 16))[2:].zfill(4)

        if DEBUG:
            print()
            print("Hex Value:", hexChar)
            print("Binary of Hex Value:", binValue)
        
        # parse binary value until we reach a non zero value
        # keep count of leading zeros
        for num in binValue:
            if num.isdigit() and int(num) == 0:
                leadingZeros = leadingZeros + 1
            else:
                nonZeroVal = 1
                break
        if nonZeroVal == 1:
            break

    if DEBUG:
        print()
        print("leadingZeros:", leadingZeros)
        print("given leading zeros:", GIVEN_LEADING_ZEROS)

    ACTUAL_LEADING_ZERO_BITS = leadingZeros

    # account for missing/duplicate leading zeros from pow header file
    if GIVEN_LEADING_ZEROS is None and not DUPLICATE_LEADING_ZEROS:
        print("ERROR: Leading-zero-bits value is missing from pow header file")
        return
    elif DUPLICATE_LEADING_ZEROS:
        print("ERROR: Multiple Leading-zero-bits values found in pow header file")
        return

    if GIVEN_LEADING_ZEROS.isnumeric() and (ACTUAL_LEADING_ZERO_BITS == int(GIVEN_LEADING_ZEROS)):
        print("PASSED: leading bits is correct")
    else:
        #invalid proof of work
        print("ERROR: Leading-zero-bits value:", GIVEN_LEADING_ZEROS + ", but hash has", \
                    ACTUAL_LEADING_ZERO_BITS, "leading zero bits")
        VERIFICATION_RESULT = 0

# check final hash given in pow header file against calculated final header hash 
def verify_final_hash():

    global ACTUAL_FINAL_HASH, VERIFICATION_RESULT

    if DEBUG:
        print()
        print("verifying final hash")
        print("GIVEN:", GIVEN_FINAL_HASH)
        print("expected:", ACTUAL_FINAL_HASH)

    if (ACTUAL_FINAL_HASH is None or ACTUAL_FINAL_HASH == ""):
        print("ERROR: pow has does not match Hash header")
        print('\t' + "Could not calculate Hash Value")
        print('\t' + "header has:", GIVEN_FINAL_HASH)
        return

    if GIVEN_FINAL_HASH is None and not DUPLICATE_FINAL_HASH:
        print("ERROR: pow hash does not match Hash header")
        print('\t' + "expected:", ACTUAL_FINAL_HASH)
        print('\t' + "header is missing Hash header")
        return
    elif DUPLICATE_FINAL_HASH:
        print("ERROR: pow hash does not match Hash header")
        print('\t' + "expected:", ACTUAL_FINAL_HASH)
        print('\t' + "header has multiple Hash values in pow file")
        return
    
    if GIVEN_FINAL_HASH == ACTUAL_FINAL_HASH:
        print("PASSED: pow hash matches Hash header")
    else:
        print("ERROR: pow hash does not match Hash header")
        print('\t' + "expected:", ACTUAL_FINAL_HASH)
        print('\t' + "header has:", GIVEN_FINAL_HASH)
        VERIFICATION_RESULT = 0

    
    

def main():
    
    # error handling
    if len(sys.argv) != 3 or sys.argv[1] == "" or sys.argv[2] == "":
        print("ERROR: Invalid Number of Arguments")
        print("fail")
        exit()

    powHeader = sys.argv[1]
    inputFile = sys.argv[2]
    
    if (not os.path.exists(powHeader)) or (os.path.getsize(powHeader) == 0):
        print("ERROR: Invalid/Empty pow header file:", powHeader)
        print("fail")
        exit()

    if (not os.path.exists(inputFile)) or (os.path.getsize(inputFile) == 0):
        print("ERROR: Invalid/Empty reference file:", inputFile)
        print("fail")
        exit()

    global ACTUAL_FILE_HASH_VAL, ACTUAL_FINAL_HASH, ACTUAL_LEADING_ZEROS
    readInputFile = open(inputFile, "rb")
    readInput = readInputFile.read()
    readPowHeaderFile = open(powHeader, "r")
    readPowHeader = readPowHeaderFile.read()
    
    verify_pow_file_format(readPowHeader)

    ACTUAL_FILE_HASH_VAL = getHashValHexDigest(readInput)
    verify_initial_hash_values()
    verify_leading_zeros()
    verify_final_hash()

    readPowHeaderFile.close()
    readInputFile.close()

    #need error handling before this point
    # check for additional cases

    if VERIFICATION_RESULT:
        print("pass")
    else:
        print("fail")

if __name__ == "__main__":
    main()